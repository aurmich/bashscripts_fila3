<<<<<<< HEAD
=======
analizza l'intero progetto a partire dalla root ed esegui phpstan su ogni modulo all’interno della cartella laravel/Modules dal livello 1 al livello 10. phpstan è già installato nella cartella laravel e va eseguito con il comando ./vendor/bin/phpstan. per ogni livello salva i report json nella cartella docs/phpstan del modulo con il nome level_<livello>.json e crea anche il file level_<livello>.md contenente l’analisi degli errori e le soluzioni proposte. prima di implementare correzioni, studia e aggiorna la documentazione del modulo, concentrandoti su ciò che viene fatto e perché viene fatto, senza includere dettagli implementativi o codice. successivamente aggiorna anche la cartella docs principale nella root del progetto aggiungendo collegamenti bidirezionali verso i file aggiornati della documentazione del modulo. ogni sottocartella in laravel/Modules rappresenta un modulo indipendente. ogni modulo ha il proprio composer.json che va analizzato per determinare correttamente namespace, autoload e struttura. il namespace delle classi non deve includere “app” anche se presente nel path: ad esempio, se un file è in laravel/Modules/<nome_modulo>/app/Filament, il namespace corretto sarà Modules<nome_modulo>\Filament. ogni modulo deve avere una cartella app per contenere le classi e una cartella docs con la documentazione tecnica e le correzioni locali. la documentazione nella root invece rappresenta l’architettura generale, la roadmap, le epiche e la filosofia del progetto. entrambe vanno mantenute aggiornate e allineate. per ogni errore phpstan, studia la documentazione locale più vicina, aggiorna il contenuto spiegando l’intento e le motivazioni architetturali, poi procedi con la correzione mantenendo coerenza con lo stile del progetto e senza introdurre rotture. verifica se sono presenti funzionalità mancanti come ->colors($metatag->getColors()) o -><nome>($metatag->get<nome>()). se mancano, studia la logica, documenta il perché e crea le funzioni necessarie nella struttura corretta del modulo. se è necessario creare uno script shell, deve essere creato all'interno della cartella bashscripts più vicina nel progetto, cercandola senza mai crearne una nuova. non modificare in alcun modo il file phpstan.neon. le funzioni getListTableColumns, getTableActions e getTableBulkActions devono restituire array in cui le chiavi sono stringhe, e questa struttura deve essere mantenuta in tutte le dichiarazioni, inferenze e implementazioni. al termine della correzione di ogni livello phpstan, fornisci un breve riepilogo delle modifiche effettuate e dei possibili impatti futuri, spiegando le scelte architetturali adottate. procedi in modo continuo, sistematico, automatico e senza interruzioni né richieste ulteriori.
phpstan e' gia' installato dentro la cartella laravel lo esegui con ./vendor/bin/phpstan
devi analizzare ogni singola cartella dentro laravel/Modules queste cartelle sono moduli, da livello 1 a livello 10 , ogni modulo ha la sua cartella docs/phpstan dentro ci metti il file level_<level>.json che lo crea in automatico phpstan , poi studiando e aggiornando la cartella docs del modulo e analizzando e ragionando sul codice del modulo scrivi il file level_<level>.md con come correggere gli errori, pero' devi aver ben in chiaro lo scopo , quando correggi un file controlli di non aver distrutto il sito

devi analizzare con phpstan tutto modules  e prima di correggere studi e aggiorni la cartella docs piu' vicina all'errore e poi coi file che hai aggiornato crei dei collegamenti bidirezionali coi file adeguati dentro la cartella docs della root del progetto, la cartella docs della root del progetto ti serve come indice di dove andare a prendere le informazioni coerenti coi moduli che sono presenti nella cartella docs del modulo , nella cartella docs della root del progetto c'e' questo indice, e la descrizione generale del progetto con la sua roadmap, epiche, story, sprint, politica, religione, filosofia, zen , poi fatto tutto questo correggi l'errore e poi passi all'errore dopo in maniera sistematica, automatica, senza interruzioni,

su laravel/Modules/Xot/app/Actions/Panel/ApplyMetatagToPanelAction.php
alla chiamata ->colors($metatag->getColors()   alla chiamata -><nome>($metatag->get<nome>())   se in MetatagData non c'e' quella funzione deve essere creata ! ragiona sul perche' scrivilo nella cartella docs adeguata, studia quella cartella, aggiorna le tue rules, le tue memories e poi procedi con implementazione correzione


Analizza con PHPStan ogni modulo in laravel/Modules dal livello 1 al 10, correggendo tutti gli errori in modo autonomo e strutturato.
Procedura:

Esegui ./vendor/bin/phpstan su ogni modulo
Salva i report JSON nella cartella docs/phpstan DENTRO OGNI SINGOLO MODULO (es: laravel/Modules/Auth/docs/phpstan/level_1.json)
Studia e aggiorna la documentazione specifica del modulo in esame
Crea file level_<livello>.md DENTRO LA CARTELLA docs/phpstan DEL MODULO analizzato
Implementa correzioni secondo l'architettura ottimale, non la più facile
Procedi sistematicamente all'errore successivo senza richiedere approvazioni o interruzioni

La documentazione nei singoli moduli (laravel/Modules/[NomeModulo]/docs/) contiene specifiche tecniche e correzioni locali; la documentazione root (laravel/docs/) contiene l'architettura generale, roadmap, epiche e filosofia del progetto. Mantieni collegamenti bidirezionali tra queste documentazioni per garantire coerenza e navigabilità.
Per funzionalità mancanti (es. ->colors($metatag->getColors())), analizza il contesto, documenta la logica nelle cartelle docs DEL MODULO SPECIFICO e implementa la soluzione strutturale più coerente con l'architettura esistente.
Dopo ogni correzione, verifica la funzionalità complessiva del sistema prima di procedere, preservando l'integrità dell'applicazione. Il processo deve essere completamente autonomo e scegliere sempre l'approccio architettonicamente superiore.

>>>>>>> aurmich/dev

--- singolo modulo
analizza l’intero progetto a partire dalla cartella root eseguendo phpstan dal livello 1 al livello 10 su ogni modulo all’interno della cartella laravel/Modules, utilizzando il comando ./vendor/bin/phpstan già presente nella cartella laravel, salvando per ogni livello i report json nella cartella docs/phpstan del modulo con il nome level_<livello>.json e scrivendo anche un file level_<livello>.md contenente l’analisi degli errori e le soluzioni proposte, dopo aver studiato e aggiornato la documentazione tecnica del modulo per comprenderne scopo e logica senza includere codice o dettagli implementativi, e aggiornando successivamente anche la documentazione generale nella cartella docs della root aggiungendo collegamenti bidirezionali con i file del modulo, assicurandoti che ogni modulo abbia una cartella app per le classi, una cartella docs per la documentazione tecnica e che ogni composer.json locale venga analizzato per rilevare il namespace corretto che non deve includere "app" anche se presente nel path, mantenendo la coerenza del namespace ad esempio come Modules\NomeModulo\Filament, verificando inoltre che ogni funzione getListTableColumns, getTableActions e getTableBulkActions restituisca array con chiavi stringa, senza mai modificare il file phpstan.neon e senza creare nuove cartelle bashscripts ma cercando quella più vicina se necessario generare uno script shell, analizzando per ogni errore la documentazione più prossima, aggiornandola con le motivazioni architetturali e implementando le correzioni senza rompere il sistema, procedendo in modo continuo e automatico fino alla completa risoluzione, e nel caso in cui vengano rilevate chiamate come ->colors($metatag->getColors()) o simili in ApplyMetatagToPanelAction.php, se mancano metodi corrispondenti in MetatagData devono essere creati e documentati nella cartella docs più pertinente, seguendo sempre la filosofia e le convenzioni del progetto.


<<<<<<< HEAD
-------- tutto modules 

analizza l’intero contenuto della cartella laravel/Modules come un unico insieme coerente ed esegui PHPStan dal livello 9 al livello 9, utilizzando il comando ./vendor/bin/phpstan (già installato nella cartella laravel). per ogni livello salva il report JSON globale in ../docs/phpstan/level_<livello>.json e genera docs/phpstan/level_<livello>.md contenente analisi dettagliata degli errori, relazioni e dipendenze tra moduli, soluzioni architetturali proposte e scelte strategiche adottate. studia e aggiorna prima la documentazione tecnica nei moduli coinvolti, poi quella generale in docs/ (root del progetto), che funge da indice centrale e non contiene la documentazione esaustiva. la documentazione approfondita e tecnica si trova invece nelle cartelle docs dei singoli moduli, e deve essere collegata bidirezionalmente con la documentazione root. crea sempre questi collegamenti incrociati. tratta ogni cartella dentro laravel/Modules come un modulo indipendente con proprio composer.json, determinando namespace, autoload e struttura dinamicamente. non includere “app” nel namespace (es. laravel/Modules/Auth/app/Foo → Modules\Auth\Foo). non modificare mai il file phpstan.neon. le funzioni getListTableColumns, getTableActions e getTableBulkActions devono restituire array con chiavi stringa. se il metodo getTableActions restituisce solo ViewAction, EditAction e DeleteAction, rimuovilo del tutto. se invece contiene anche azioni aggiuntive, l'array restituito deve includere ...parent::getTableActions(). se il metodo getTableBulkActions restituisce solo DeleteBulkAction, rimuovilo del tutto. se invece contiene anche azioni aggiuntive, l'array restituito deve includere ...parent::getTableBulkActions(). le funzionalità come ->colors($metatag->getColors()) o -><nome>($metatag->get<Nome>()) devono avere metodi definiti in MetatagData. se mancanti, documenta perché devono esistere, poi implementali coerentemente nel modulo corretto. se servono script shell, cerca la cartella bashscripts più vicina senza crearne di nuove. non usare mai ->label('') perché tutte le etichette devono essere gestite tramite i file di traduzione localizzati nei moduli usando il LangServiceProvider. procedi in modo continuo, sistematico, automatico e senza interruzioni, mantenendo coerenza architetturale, senza rompere funzionalità esistenti. dopo ogni livello di analisi fornisci un riepilogo con sintesi delle modifiche, scelte architetturali fatte e impatti futuri attesi.
=======
-------- tutto modules

analizza l’intero contenuto della cartella laravel/Modules come un unico insieme coerente ed esegui PHPStan dal livello 9 al livello 9, utilizzando il comando ./vendor/bin/phpstan (già installato nella cartella laravel). per ogni livello salva il report JSON globale in ../docs/phpstan/level_<livello>.json e genera docs/phpstan/level_<livello>.md contenente analisi dettagliata degli errori, relazioni e dipendenze tra moduli, soluzioni architetturali proposte e scelte strategiche adottate. studia e aggiorna prima la documentazione tecnica nei moduli coinvolti, poi quella generale in docs/ (root del progetto), che funge da indice centrale e non contiene la documentazione esaustiva. la documentazione approfondita e tecnica si trova invece nelle cartelle docs dei singoli moduli, e deve essere collegata bidirezionalmente con la documentazione root. crea sempre questi collegamenti incrociati. tratta ogni cartella dentro laravel/Modules come un modulo indipendente con proprio composer.json, determinando namespace, autoload e struttura dinamicamente. non includere “app” nel namespace (es. laravel/Modules/Auth/app/Foo → Modules\Auth\Foo). non modificare mai il file phpstan.neon. le funzioni getListTableColumns, getTableActions e getTableBulkActions devono restituire array con chiavi stringa. se il metodo getTableActions restituisce solo ViewAction, EditAction e DeleteAction, rimuovilo del tutto. se invece contiene anche azioni aggiuntive, l'array restituito deve includere ...parent::getTableActions(). se il metodo getTableBulkActions restituisce solo DeleteBulkAction, rimuovilo del tutto. se invece contiene anche azioni aggiuntive, l'array restituito deve includere ...parent::getTableBulkActions(). le funzionalità come ->colors($metatag->getColors()) o -><nome>($metatag->get<Nome>()) devono avere metodi definiti in MetatagData. se mancanti, documenta perché devono esistere, poi implementali coerentemente nel modulo corretto. se servono script shell, cerca la cartella bashscripts più vicina senza crearne di nuove. non usare mai ->label('') perché tutte le etichette devono essere gestite tramite i file di traduzione localizzati nei moduli usando il LangServiceProvider. procedi in modo continuo, sistematico, automatico e senza interruzioni, mantenendo coerenza architetturale, senza rompere funzionalità esistenti. dopo ogni livello di analisi fornisci un riepilogo con sintesi delle modifiche, scelte architetturali fatte e impatti futuri attesi.
>>>>>>> aurmich/dev
